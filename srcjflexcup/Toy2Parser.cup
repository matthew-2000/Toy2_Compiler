import nodes.*;
import visitor.Visitable;
import java.util.*;

/* Dichiarazione dei terminali */
terminal VAR, PROC, FUNC, ENDVAR, ENDPROC, ENDFUNC, RETURN, IF, THEN, ELSE, ELIF, ENDIF, WHILE, DO, ENDWHILE;
terminal WRITE, WRITERETURN, READ, TRUE, FALSE;
terminal REAL, INTEGER, STRING, BOOLEAN, LPAR, RPAR, SEMI, COMMA, COLON, ASSIGN, REF, DOLLAR;
terminal PLUS, MINUS, UMINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND, OR, NOT;
terminal REAL_CONST, NUMBER_LITERAL, STRING_LITERAL;
terminal IDENTIFIER;
terminal TYPERETURN;
terminal OUT;

/* Dichiarazione dei non terminali */
non terminal Program, Iter, VarDecl, Decls, Ids, Consts, Const, Type;
non terminal Function, FuncParams, OtherFuncParams, Types;
non terminal Procedure, ProcParams, OtherProcParams, ProcParamId;
non terminal Body, Stat, FunCall, ProcCall, IfStat, Elifs, Elif, Else, WhileStat;
non terminal IOArg, IOArgsList, ProcExprs, Exprs, Expr, IterWithoutProcedure;

/* Definizione delle precedenze degli operatori */
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQ, NE, LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;

/* Definizione del Programma principale */
Program ::= IterWithoutProcedure:iterWithoutProc Procedure:proc Iter:it
{:
    // Esegui il cast ai rispettivi tipi di nodo per evitare errori di tipo
    ProgramNode programNode = new ProgramNode(
        (IterWithoutProcedureNode) iterWithoutProc,
        (ProcedureNode) proc,
        (IterNode) it
    );
    RESULT = programNode;
:};

/* Iterazione senza procedure */
IterWithoutProcedure ::= VarDecl:varDecl IterWithoutProcedure:nextIterWithoutProc
{:
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode();
    iterNode.addItem((VarDeclNode) varDecl);
    if (nextIterWithoutProc != null) {
        iterNode.getItems().addAll(((IterWithoutProcedureNode) nextIterWithoutProc).getItems());
    }
    RESULT = iterNode;
:}
| Function:function IterWithoutProcedure:nextIterWithoutProc
{:
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode();
    iterNode.addItem((FunctionNode) function);
    if (nextIterWithoutProc != null) {
        iterNode.getItems().addAll(((IterWithoutProcedureNode) nextIterWithoutProc).getItems());
    }
    RESULT = iterNode;
:}
| /* empty */
{:
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode();
    RESULT = iterNode;
:};

/* Iterazione con procedure */
Iter ::= VarDecl:varDecl Iter:nextIter
{:
    IterNode iterNode = new IterNode();
    iterNode.addItem((VarDeclNode) varDecl);
    if (nextIter != null) {
        iterNode.getItems().addAll(((IterNode) nextIter).getItems());
    }
    RESULT = iterNode;
:}
| Function:function Iter:nextIter
{:
    IterNode iterNode = new IterNode();
    iterNode.addItem((FunctionNode) function);
    if (nextIter != null) {
        iterNode.getItems().addAll(((IterNode) nextIter).getItems());
    }
    RESULT = iterNode;
:}
| Procedure:procedure Iter:nextIter
{:
    IterNode iterNode = new IterNode();
    iterNode.addItem((ProcedureNode) procedure);
    if (nextIter != null) {
        iterNode.getItems().addAll(((IterNode) nextIter).getItems());
    }
    RESULT = iterNode;
:}
| /* empty */
{:
    IterNode iterNode = new IterNode();
    RESULT = iterNode;
:};

/* Dichiarazione di variabili */
VarDecl ::= VAR Decls:decls
{:
    VarDeclNode varDeclNode = new VarDeclNode((DeclsNode) decls);
    RESULT = varDeclNode;
:};

/* Dichiarazioni e costanti */
Decls ::= Ids:ids COLON Type:type SEMI Decls:nextDecls
{:
    List<Visitable> items = new ArrayList<>();
    items.add(new DeclsNode((IdsNode) ids, (TypeNode) type, null));
    if (nextDecls != null) {
        items.addAll(((DeclsNode) nextDecls).getItems());
    }
    DeclsNode declsNode = new DeclsNode(items);
    RESULT = declsNode;
:}
| Ids:ids ASSIGN Consts:consts SEMI Decls:nextDecls
{:
    List<Visitable> items = new ArrayList<>();
    items.add(new DeclsNode((IdsNode) ids, null, (ConstsNode) consts));
    if (nextDecls != null) {
        items.addAll(((DeclsNode) nextDecls).getItems());
    }
    DeclsNode declsNode = new DeclsNode(items);
    RESULT = declsNode;
:}
| Ids:ids COLON Type:type SEMI ENDVAR
{:
    List<Visitable> items = new ArrayList<>();
    items.add(new DeclsNode((IdsNode) ids, (TypeNode) type, null));
    DeclsNode declsNode = new DeclsNode(items);
    RESULT = declsNode;
:}
| Ids:ids ASSIGN Consts:consts SEMI ENDVAR
{:
    List<Visitable> items = new ArrayList<>();
    items.add(new DeclsNode((IdsNode) ids, null, (ConstsNode) consts));
    DeclsNode declsNode = new DeclsNode(items);
    RESULT = declsNode;
:};

/* Lista di identificatori */
Ids ::= IDENTIFIER:id COMMA Ids:nextIds
{:
    List<String> identifiers = new ArrayList<>();
    identifiers.add(id.toString());
    if (nextIds != null) {
        identifiers.addAll(((IdsNode) nextIds).getIdentifiers());
    }
    IdsNode idsNode = new IdsNode(identifiers);
    RESULT = idsNode;
:}
| IDENTIFIER:id
{:
    List<String> identifiers = new ArrayList<>();
    identifiers.add(id.toString());
    IdsNode idsNode = new IdsNode(identifiers);
    RESULT = idsNode;
:};

/* Lista di costanti */
Consts ::= Const:constant COMMA Consts:nextConsts
{:
    List<ConstNode> constants = new ArrayList<>();
    constants.add((ConstNode) constant);
    if (nextConsts != null) {
        constants.addAll(((ConstsNode) nextConsts).getConstants());
    }
    ConstsNode constsNode = new ConstsNode(constants);
    RESULT = constsNode;
:}
| Const:constant
{:
    List<ConstNode> constants = new ArrayList<>();
    constants.add((ConstNode) constant);
    ConstsNode constsNode = new ConstsNode(constants);
    RESULT = constsNode;
:};

/* Definizione di una costante */
Const ::= REAL_CONST:realConst
{:
    ConstNode constNode = new ConstNode(realConst.toString(), "REAL_CONST");
    RESULT = constNode;
:}
| NUMBER_LITERAL:number
{:
    ConstNode constNode = new ConstNode(number.toString(), "NUMBER_LITERAL");
    RESULT = constNode;
:}
| STRING_LITERAL:stringLiteral
{:
    ConstNode constNode = new ConstNode(stringLiteral.toString(), "STRING_LITERAL");
    RESULT = constNode;
:}
| TRUE
{:
    ConstNode constNode = new ConstNode("true", "BOOLEAN");
    RESULT = constNode;
:}
| FALSE
{:
    ConstNode constNode = new ConstNode("false", "BOOLEAN");
    RESULT = constNode;
:};

/* Definizione di un tipo */
Type ::= REAL
{:
    TypeNode typeNode = new TypeNode("REAL");
    RESULT = typeNode;
:}
| INTEGER
{:
    TypeNode typeNode = new TypeNode("INTEGER");
    RESULT = typeNode;
:}
| STRING
{:
    TypeNode typeNode = new TypeNode("STRING");
    RESULT = typeNode;
:}
| BOOLEAN
{:
    TypeNode typeNode = new TypeNode("BOOLEAN");
    RESULT = typeNode;
:};

/* Definizione di una funzione */
Function ::= FUNC IDENTIFIER:funcName LPAR FuncParams:params RPAR TYPERETURN Types:returnType COLON Body:body ENDFUNC
{:
    FunctionNode functionNode = new FunctionNode(
        funcName.toString(),
        (FuncParamsNode) params,
        (TypesNode) returnType,
        (BodyNode) body
    );
    RESULT = functionNode;
:};

/* Parametri di una funzione */
FuncParams ::= IDENTIFIER:id COLON Type:type OtherFuncParams:otherParams
{:
    List<FuncParamIdNode> params = new ArrayList<>();
    params.add(new FuncParamIdNode(id.toString(), (TypeNode) type));
    if (otherParams != null) {
        params.addAll(((FuncParamsNode) otherParams).getParams());
    }
    FuncParamsNode funcParamsNode = new FuncParamsNode(params);
    RESULT = funcParamsNode;
:}
| /* empty */
{:
    FuncParamsNode funcParamsNode = new FuncParamsNode(new ArrayList<>());
    RESULT = funcParamsNode;
:};

/* Altri parametri di una funzione */
OtherFuncParams ::= COMMA IDENTIFIER:id COLON Type:type OtherFuncParams:otherParams
{:
    List<FuncParamIdNode> params = new ArrayList<>();
    params.add(new FuncParamIdNode(id.toString(), (TypeNode) type));
    if (otherParams != null) {
        params.addAll(((FuncParamsNode) otherParams).getParams());
    }
    FuncParamsNode otherFuncParamsNode = new FuncParamsNode(params);
    RESULT = otherFuncParamsNode;
:}
| /* empty */
{:
    FuncParamsNode otherFuncParamsNode = new FuncParamsNode(new ArrayList<>());
    RESULT = otherFuncParamsNode;
:};

/* Definizione di una lista di tipi */
Types ::= Type:type COMMA Types:nextTypes
{:
    List<TypeNode> types = new ArrayList<>();
    types.add((TypeNode) type);
    if (nextTypes != null) {
        types.addAll(((TypesNode) nextTypes).getTypes());
    }
    TypesNode typesNode = new TypesNode(types);
    RESULT = typesNode;
:}
| Type:type
{:
    List<TypeNode> types = new ArrayList<>();
    types.add((TypeNode) type);
    TypesNode typesNode = new TypesNode(types);
    RESULT = typesNode;
:};

/* Parametri di una procedura */
ProcParams ::= ProcParamId:paramId COLON Type:type OtherProcParams:otherParams
{:
    List<ProcParamIdNode> params = new ArrayList<>();
    params.add(new ProcParamIdNode(paramId.getName(), (TypeNode) type, paramId.isOut()));
    if (otherParams != null) {
        params.addAll(((ProcParamsNode) otherParams).getParams());
    }
    ProcParamsNode procParamsNode = new ProcParamsNode(params);
    RESULT = procParamsNode;
:}
| /* empty */
{:
    ProcParamsNode procParamsNode = new ProcParamsNode(new ArrayList<>());
    RESULT = procParamsNode;
:};

/* Altri parametri di una procedura */
OtherProcParams ::= COMMA ProcParamId:paramId COLON Type:type OtherProcParams:otherParams
{:
    List<ProcParamIdNode> params = new ArrayList<>();
    params.add(new ProcParamIdNode(paramId.getName(), (TypeNode) type, paramId.isOut()));
    if (otherParams != null) {
        params.addAll(((ProcParamsNode) otherParams).getParams());
    }
    ProcParamsNode otherProcParamsNode = new ProcParamsNode(params);
    RESULT = otherProcParamsNode;
:}
| /* empty */
{:
    ProcParamsNode otherProcParamsNode = new ProcParamsNode(new ArrayList<>());
    RESULT = otherProcParamsNode;
:};

/* Altri parametri di una procedura */
OtherProcParams ::= COMMA ProcParamId:paramId COLON Type:type OtherProcParams:otherParams
{:
    List<ParamNode> params = new ArrayList<>();
    params.add(new ParamNode((ProcParamIdNode) paramId, (TypeNode) type));
    if (otherParams != null) {
        params.addAll(((ProcParamsNode) otherParams).getParams());
    }
    ProcParamsNode otherProcParamsNode = new ProcParamsNode(params);
    RESULT = otherProcParamsNode;
:}
| /* empty */
{:
    ProcParamsNode otherProcParamsNode = new ProcParamsNode(new ArrayList<>());
    RESULT = otherProcParamsNode;
:};

/* Definizione di un parametro di procedura */
ProcParamId ::= IDENTIFIER:identifier
{:
    ProcParamIdNode paramIdNode = new ProcParamIdNode(identifier.toString(), false);
    RESULT = paramIdNode;
:}
| OUT IDENTIFIER:identifier
{:
    ProcParamIdNode paramIdNode = new ProcParamIdNode(identifier.toString(), true);
    RESULT = paramIdNode;
:};

/* Definizione del corpo di una funzione o procedura */
Body ::= VarDecl:varDecl Body:nextBody
{:
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) varDecl);
    if (nextBody != null) {
        items.addAll(((BodyNode) nextBody).getItems());
    }
    BodyNode bodyNode = new BodyNode(items);
    RESULT = bodyNode;
:}
| Stat:stat Body:nextBody
{:
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) stat);
    if (nextBody != null) {
        items.addAll(((BodyNode) nextBody).getItems());
    }
    BodyNode bodyNode = new BodyNode(items);
    RESULT = bodyNode;
:}
| /* empty */
{:
    BodyNode bodyNode = new BodyNode(new ArrayList<>());
    RESULT = bodyNode;
:};

/* Dichiarazione delle istruzioni */
Stat ::= Ids:ids ASSIGN Exprs:exprs SEMI
{:
    StatNode statNode = new StatNode((IdsNode) ids, (ExprsNode) exprs, "ASSIGN");
    RESULT = statNode;
:}
| ProcCall:procCall SEMI
{:
    StatNode statNode = new StatNode((ProcCallNode) procCall, "PROC_CALL");
    RESULT = statNode;
:}
| RETURN Exprs:exprs SEMI
{:
    StatNode statNode = new StatNode((ExprsNode) exprs, "RETURN");
    RESULT = statNode;
:}
| WRITE IOArgsList:ioArgsList SEMI
{:
    StatNode statNode = new StatNode((IOArgsListNode) ioArgsList, "WRITE");
    RESULT = statNode;
:}
| WRITERETURN IOArgsList:ioArgsList SEMI
{:
    StatNode statNode = new StatNode((IOArgsListNode) ioArgsList, "WRITERETURN");
    RESULT = statNode;
:}
| READ IOArgsList:ioArgsList SEMI
{:
    StatNode statNode = new StatNode((IOArgsListNode) ioArgsList, "READ");
    RESULT = statNode;
:}
| IfStat:ifStat SEMI
{:
    StatNode statNode = new StatNode((IfStatNode) ifStat, "IF");
    RESULT = statNode;
:}
| WhileStat:whileStat SEMI
{:
    StatNode statNode = new StatNode((WhileStatNode) whileStat, "WHILE");
    RESULT = statNode;
:};

/* Chiamate a funzione */
FunCall ::= IDENTIFIER:funcName LPAR Exprs:args RPAR
{:
    FunCallNode funCallNode = new FunCallNode(funcName.toString(), (ExprsNode) args);
    RESULT = funCallNode;
:}
| IDENTIFIER:funcName LPAR RPAR
{:
    FunCallNode funCallNode = new FunCallNode(funcName.toString(), null);
    RESULT = funCallNode;
:};

/* Chiamate a procedura */
ProcCall ::= IDENTIFIER:procName LPAR ProcExprs:args RPAR
{:
    ProcCallNode procCallNode = new ProcCallNode(procName.toString(), (ProcExprsNode) args);
    RESULT = procCallNode;
:}
| IDENTIFIER:procName LPAR RPAR
{:
    ProcCallNode procCallNode = new ProcCallNode(procName.toString(), null);
    RESULT = procCallNode;
:};

/* Definizione delle istruzioni condizionali */
IfStat ::= IF Expr:condition THEN Body:thenBody Elifs:elifBlocks Else:elseBlock ENDIF
{:
    IfStatNode ifStatNode = new IfStatNode(
        (ExprNode) condition,
        (BodyNode) thenBody,
        (ElifsNode) elifBlocks,
        (ElseNode) elseBlock
    );
    RESULT = ifStatNode;
:};

/* Liste di condizioni ELIF */
Elifs ::= Elif:elifBlock Elifs:nextElifs
{:
    List<ElifNode> elifNodes = new ArrayList<>();
    elifNodes.add((ElifNode) elifBlock);
    if (nextElifs != null) {
        elifNodes.addAll(((ElifsNode) nextElifs).getElifBlocks());
    }
    ElifsNode elifsNode = new ElifsNode(elifNodes);
    RESULT = elifsNode;
:}
| /* empty */
{:
    ElifsNode elifsNode = new ElifsNode(new ArrayList<>());
    RESULT = elifsNode;
:};

/* Condizione ELIF */
Elif ::= ELIF Expr:condition THEN Body:body
{:
    ElifNode elifNode = new ElifNode((ExprNode) condition, (BodyNode) body);
    RESULT = elifNode;
:};

/* Condizione ELSE */
Else ::= ELSE Body:body
{:
    ElseNode elseNode = new ElseNode((BodyNode) body);
    RESULT = elseNode;
:}
| /* empty */
{:
    ElseNode elseNode = new ElseNode(null);
    RESULT = elseNode;
:};

/* Definizione delle istruzioni di loop */
WhileStat ::= WHILE Expr:condition DO Body:body ENDWHILE
{:
    WhileStatNode whileStatNode = new WhileStatNode((ExprNode) condition, (BodyNode) body);
    RESULT = whileStatNode;
:};

/* Argomenti di Input/Output */
IOArgsList ::= IOArg:arg IOArgsList:nextArgs
{:
    List<IOArgNode> args = new ArrayList<>();
    args.add((IOArgNode) arg);
    if (nextArgs != null) {
        args.addAll(((IOArgsListNode) nextArgs).getArgs());
    }
    IOArgsListNode ioArgsListNode = new IOArgsListNode(args);
    RESULT = ioArgsListNode;
:}
| DOLLAR LPAR Expr:expr RPAR IOArgsList:nextArgs
{:
    List<IOArgNode> args = new ArrayList<>();
    args.add(new IOArgNode((ExprNode) expr, true));
    if (nextArgs != null) {
        args.addAll(((IOArgsListNode) nextArgs).getArgs());
    }
    IOArgsListNode ioArgsListNode = new IOArgsListNode(args);
    RESULT = ioArgsListNode;
:}
| /* empty */
{:
    IOArgsListNode ioArgsListNode = new IOArgsListNode(new ArrayList<>());
    RESULT = ioArgsListNode;
:};

/* Singolo argomento di I/O */
IOArg ::= IOArg:l PLUS IOArg:r
{:
    IOArgNode ioArgNode = new IOArgNode((IOArgNode) l, (IOArgNode) r);
    RESULT = ioArgNode;
:}
| IDENTIFIER:id
{:
    IOArgNode ioArgNode = new IOArgNode(id.toString(), false);
    RESULT = ioArgNode;
:}
| STRING_LITERAL:literal
{:
    IOArgNode ioArgNode = new IOArgNode(literal.toString());
    RESULT = ioArgNode;
:};

/* Parametri di espressioni per le procedure */
ProcExprs ::= Expr:expr COMMA ProcExprs:nextExprs
{:
    List<ProcExprNode> procExprs = new ArrayList<>();
    procExprs.add(new ProcExprNode((ExprNode) expr, false));
    if (nextExprs != null) {
        procExprs.addAll(((ProcExprsNode) nextExprs).getExpressions());
    }
    ProcExprsNode procExprsNode = new ProcExprsNode(procExprs);
    RESULT = procExprsNode;
:}
| REF IDENTIFIER:id COMMA ProcExprs:nextExprs
{:
    List<ProcExprNode> procExprs = new ArrayList<>();
    procExprs.add(new ProcExprNode(id.toString(), true));
    if (nextExprs != null) {
        procExprs.addAll(((ProcExprsNode) nextExprs).getExpressions());
    }
    ProcExprsNode procExprsNode = new ProcExprsNode(procExprs);
    RESULT = procExprsNode;
:}
| Expr:expr
{:
    List<ProcExprNode> procExprs = new ArrayList<>();
    procExprs.add(new ProcExprNode((ExprNode) expr, false));
    ProcExprsNode procExprsNode = new ProcExprsNode(procExprs);
    RESULT = procExprsNode;
:}
| REF IDENTIFIER:id
{:
    List<ProcExprNode> procExprs = new ArrayList<>();
    procExprs.add(new ProcExprNode(id.toString(), true));
    ProcExprsNode procExprsNode = new ProcExprsNode(procExprs);
    RESULT = procExprsNode;
:};


/* Lista di espressioni */
Exprs ::= Expr:expr COMMA Exprs:nextExprs
{:
    List<ExprNode> exprs = new ArrayList<>();
    exprs.add((ExprNode) expr);
    if (nextExprs != null) {
        exprs.addAll(((ExprsNode) nextExprs).getExpressions());
    }
    ExprsNode exprsNode = new ExprsNode(exprs);
    RESULT = exprsNode;
:}
| Expr:expr
{:
    List<ExprNode> exprs = new ArrayList<>();
    exprs.add((ExprNode) expr);
    ExprsNode exprsNode = new ExprsNode(exprs);
    RESULT = exprsNode;
:};


/* Definizione di espressioni */
Expr ::= FunCall:funCall
{:
    RESULT = funCall;
:}
| REAL_CONST:realConst
{:
    ExprNode exprNode = new ExprNode(realConst.toString(), "REAL_CONST");
    RESULT = exprNode;
:}
| NUMBER_LITERAL:number
{:
    ExprNode exprNode = new ExprNode(number.toString(), "NUMBER_LITERAL");
    RESULT = exprNode;
:}
| STRING_LITERAL:stringLiteral
{:
    ExprNode exprNode = new ExprNode(stringLiteral.toString(), "STRING_LITERAL");
    RESULT = exprNode;
:}
| IDENTIFIER:id
{:
    ExprNode exprNode = new ExprNode(id.toString(), "IDENTIFIER");
    RESULT = exprNode;
:}
| TRUE
{:
    ExprNode exprNode = new ExprNode("true", "BOOLEAN");
    RESULT = exprNode;
:}
| FALSE
{:
    ExprNode exprNode = new ExprNode("false", "BOOLEAN");
    RESULT = exprNode;
:}
| Expr:l PLUS Expr:r
{:
    ExprNode exprNode = new ExprNode("+", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l MINUS Expr:r
{:
    ExprNode exprNode = new ExprNode("-", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l TIMES Expr:r
{:
    ExprNode exprNode = new ExprNode("*", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l DIV Expr:r
{:
    ExprNode exprNode = new ExprNode("/", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l AND Expr:r
{:
    ExprNode exprNode = new ExprNode("AND", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l OR Expr:r
{:
    ExprNode exprNode = new ExprNode("OR", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l GT Expr:r
{:
    ExprNode exprNode = new ExprNode(">", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l GE Expr:r
{:
    ExprNode exprNode = new ExprNode(">=", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l LT Expr:r
{:
    ExprNode exprNode = new ExprNode("<", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l LE Expr:r
{:
    ExprNode exprNode = new ExprNode("<=", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l EQ Expr:r
{:
    ExprNode exprNode = new ExprNode("==", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| Expr:l NE Expr:r
{:
    ExprNode exprNode = new ExprNode("!=", (ExprNode) l, (ExprNode) r);
    RESULT = exprNode;
:}
| LPAR Expr:expr RPAR
{:
    RESULT = expr;
:}
| MINUS Expr:expr
{:
    ExprNode exprNode = new ExprNode("MINUS", (ExprNode) expr);
    RESULT = exprNode;
:}
| NOT Expr:expr
{:
    ExprNode exprNode = new ExprNode("NOT", (ExprNode) expr);
    RESULT = exprNode;
:};


import nodes.*;
import visitor.Visitable;
import java.util.*;

/* Dichiarazione dei terminali */
terminal VAR, PROC, FUNC, ENDVAR, ENDPROC, ENDFUNC, RETURN, IF, THEN, ELSE, ELIF, ENDIF, WHILE, DO, ENDWHILE;
terminal WRITE, WRITERETURN, READ, TRUE, FALSE;
terminal REAL, INTEGER, STRING, BOOLEAN, LPAR, RPAR, SEMI, COMMA, COLON, ASSIGN, REF, DOLLAR;
terminal PLUS, MINUS, UMINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND, OR, NOT;
terminal REAL_CONST, NUMBER_LITERAL, STRING_LITERAL;
terminal IDENTIFIER;
terminal TYPERETURN;
terminal OUT;

/* Dichiarazione dei non terminali */
non terminal Program, Iter, VarDecl, Decls, Ids, Consts, Const, Type;
non terminal Function, FuncParams, OtherFuncParams, Types;
non terminal Procedure, ProcParams, OtherProcParams, ProcParamId;
non terminal Body, Stat, FunCall, ProcCall, IfStat, Elifs, Elif, Else, WhileStat;
non terminal IOArg, IOArgsList, ProcExprs, Exprs, Expr, IterWithoutProcedure;

/* Definizione delle precedenze degli operatori */
precedence left OR;
precedence left AND;
precedence right NOT;
precedence nonassoc EQ, NE, LT, LE, GT, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;

/* Definizione del Programma principale */
Program ::= IterWithoutProcedure:iterWithoutProc Procedure:proc Iter:it
{:
    // Esegui il cast ai rispettivi tipi di nodo per evitare errori di tipo
    ProgramNode programNode = new ProgramNode(
        (IterWithoutProcedureNode) iterWithoutProc,
        (ProcedureNode) proc,
        (IterNode) it
    );
    RESULT = programNode;
:};

IterWithoutProcedure ::= VarDecl:varDecl IterWithoutProcedure:nextIterWithoutProc
{:
    // Accumula il nodo VarDecl in una lista insieme ai nodi successivi
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) varDecl);
    if (nextIterWithoutProc != null) {
        items.addAll(((IterWithoutProcedureNode) nextIterWithoutProc).getItems());
    }
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode(items);
    RESULT = iterNode;
:}
| Function:function IterWithoutProcedure:nextIterWithoutProc
{:
    // Accumula il nodo Function in una lista insieme ai nodi successivi
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) function);
    if (nextIterWithoutProc != null) {
        items.addAll(((IterWithoutProcedureNode) nextIterWithoutProc).getItems());
    }
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode(items);
    RESULT = iterNode;
:}
| /* empty */
{:
    // Nodo vuoto con lista vuota per IterWithoutProcedure
    IterWithoutProcedureNode iterNode = new IterWithoutProcedureNode(new ArrayList<>());
    RESULT = iterNode;
:};

/* Iterazione con procedure */
Iter ::= VarDecl:varDecl Iter:nextIter
{:
    // Accumula il nodo VarDecl in una lista insieme ai nodi successivi
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) varDecl);
    if (nextIter != null) {
        items.addAll(((IterNode) nextIter).getItems());
    }
    IterNode iterNode = new IterNode(items);
    RESULT = iterNode;
:}
| Function:function Iter:nextIter
{:
    // Accumula il nodo Function in una lista insieme ai nodi successivi
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) function);
    if (nextIter != null) {
        items.addAll(((IterNode) nextIter).getItems());
    }
    IterNode iterNode = new IterNode(items);
    RESULT = iterNode;
:}
| Procedure:procedure Iter:nextIter
{:
    // Accumula il nodo Procedure in una lista insieme ai nodi successivi
    List<Visitable> items = new ArrayList<>();
    items.add((Visitable) procedure);
    if (nextIter != null) {
        items.addAll(((IterNode) nextIter).getItems());
    }
    IterNode iterNode = new IterNode(items);
    RESULT = iterNode;
:}
| /* empty */
{:
    // Nodo vuoto con lista vuota per Iter
    IterNode iterNode = new IterNode(new ArrayList<>());
    RESULT = iterNode;
:};

/* Dichiarazione di variabili */
VarDecl ::= VAR Decls;

/* Dichiarazioni e costanti */
Decls ::= Ids COLON Type SEMI Decls
        | Ids ASSIGN Consts SEMI Decls
        | Ids COLON Type SEMI ENDVAR
        | Ids ASSIGN Consts SEMI ENDVAR;

/* Lista di identificatori */
Ids ::= IDENTIFIER COMMA Ids
      | IDENTIFIER;

/* Lista di costanti */
Consts ::= Const COMMA Consts
         | Const;

/* Definizione di una costante */
Const ::= REAL_CONST
        | NUMBER_LITERAL
        | STRING_LITERAL
        | TRUE
        | FALSE;

/* Definizione di un tipo */
Type ::= REAL
       | INTEGER
       | STRING
       | BOOLEAN;

/* Definizione di una funzione */
Function ::= FUNC IDENTIFIER LPAR FuncParams RPAR TYPERETURN Types COLON Body ENDFUNC;

/* Parametri di una funzione */
FuncParams ::= IDENTIFIER COLON Type OtherFuncParams
             | /* empty */;

/* Altri parametri di una funzione */
OtherFuncParams ::= COMMA IDENTIFIER COLON Type OtherFuncParams
                  | /* empty */;

/* Definizione di una lista di tipi */
Types ::= Type COMMA Types
        | Type;

/* Definizione di una procedura */
Procedure ::= PROC IDENTIFIER LPAR ProcParams RPAR COLON Body ENDPROC;

/* Parametri di una procedura */
ProcParams ::= ProcParamId COLON Type OtherProcParams
             | /* empty */;

/* Altri parametri di una procedura */
OtherProcParams ::= COMMA ProcParamId COLON Type OtherProcParams
                  | /* empty */;

/* Definizione di un parametro di procedura */
ProcParamId ::= IDENTIFIER
              | OUT IDENTIFIER;

/* Definizione del corpo di una funzione o procedura */
Body ::= VarDecl Body
       | Stat Body
       | /* empty */;

/* Dichiarazione delle istruzioni */
Stat ::= Ids ASSIGN Exprs SEMI
       | ProcCall SEMI
       | RETURN Exprs SEMI
       | WRITE IOArgsList SEMI
       | WRITERETURN IOArgsList SEMI
       | READ IOArgsList SEMI
       | IfStat SEMI
       | WhileStat SEMI;

/* Chiamate a funzione */
FunCall ::= IDENTIFIER LPAR Exprs RPAR
          | IDENTIFIER LPAR RPAR;

/* Chiamate a procedura */
ProcCall ::= IDENTIFIER LPAR ProcExprs RPAR
           | IDENTIFIER LPAR RPAR;

/* Definizione delle istruzioni condizionali */
IfStat ::= IF Expr THEN Body Elifs Else ENDIF;

/* Liste di condizioni ELIF */
Elifs ::= Elif Elifs
        | /* empty */;

/* Condizione ELIF */
Elif ::= ELIF Expr THEN Body;

/* Condizione ELSE */
Else ::= ELSE Body
       | /* empty */;

/* Definizione delle istruzioni di loop */
WhileStat ::= WHILE Expr DO Body ENDWHILE;

/* Argomenti di Input/Output */
IOArgsList ::= IOArg IOArgsList
             | DOLLAR LPAR Expr RPAR IOArgsList
             | /* empty */;

/* Singolo argomento di I/O */
IOArg ::= IOArg PLUS IOArg
        | IDENTIFIER
        | STRING_LITERAL;

/* Parametri di espressioni per le procedure */
ProcExprs ::= Expr COMMA ProcExprs
            | REF IDENTIFIER COMMA ProcExprs
            | Expr
            | REF IDENTIFIER;

/* Lista di espressioni */
Exprs ::= Expr COMMA Exprs
        | Expr;

/* Definizione di espressioni */
Expr ::= FunCall
       | REAL_CONST
       | NUMBER_LITERAL
       | STRING_LITERAL
       | IDENTIFIER
       | TRUE
       | FALSE
       | Expr PLUS Expr
       | Expr MINUS Expr
       | Expr TIMES Expr
       | Expr DIV Expr
       | Expr AND Expr
       | Expr OR Expr
       | Expr GT Expr
       | Expr GE Expr
       | Expr LT Expr
       | Expr LE Expr
       | Expr EQ Expr
       | Expr NE Expr
       | LPAR Expr RPAR
       | MINUS Expr
       | NOT Expr;
